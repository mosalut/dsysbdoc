# deploy

_deploy_ 是部署任务。_DSYSB_中的任务，类似以太坊中的智能合约。_DSYSB_中定义了一套[任务指令集](dsysbinstruction_zh.md)

一个任务主要有指令和数据空间组成，指令操作数据空间，修改其数据。任务发布时，这些指令不会执行，但是会检测指令是否有语法错误，比如一个指令号后面的参数数量不足等。这一点很像其他语言中的编译时错误

任务跟资产一样，也有生命力，并且存在意义和机制也是一样的

## 字段
- _instructs_ 一个字节数组，里面包含了一条或多条指令，小端序
- _vData_ 一个字节数组，他代表了指令操作的空间的初始值，小端序
- _price_ 生命力单价
- _block_ 生命力
- _from_ 部署者钱包地址
- _hier_ 继承者钱包地址
- _nonce_ 防重放攻击
- _bytePrice_ 字节单价
- _signer_ 签名


整个 _deploy_ 命令的长度，不允许超过65536，因为其他的字段还占有固定的空间，所以 _instructs_ + _vData_ 的长度不得超过 65353

每一条指令的指令号，占一个字节，后面的参数如果指向 _vdata_ 中的索引，（类似于内存地址），占两个字节，因为最多不会超过65353，两个字节可以管理 65536个字节数据，所以够了

以下是一个完整的 _deploy_ 事务命令：

```bash
$ ./dsysbcmd create deploy '{"instructs":[0,5,0,6,0,3,0],"vData":[0,1,2,3,4,5,6,7,8,9,100],"from":"DCUz2Z2D8C9YC7ZWaVBwAx16vygpAG4fST","price":1,"blocks":10000,"bytePrice":1}'
```

等两个以上区块，然后可以像查看资产那样使用 _gettasks_ 和 _gettask_ 命令查看任务

任务中有一个 _remain_ 字段，表示还剩多少生命力

[0,5,0,6,0,3,0] 注意这里是十进制写法，每个字节都可以是 0 - 255

其中第一个0 代表指令号 是对应的指令名是 _ins\_movsb_，作用是 copy 自己数组

后面紧跟的 5,0 是源所在 _vdata_ 的位置， 因为小端序的原因，要看成 05 也就是 vData[5] 

再后面跟的 6,0 是目标所在 _vdata_ 的位置， 因为小端序的原因，要看成 06 也就是 vData[6] 

最后面跟的 3,0 是目标所在要拷贝的长度， 因为小端序的原因，要看成 03 也就是拷贝3个字节

所以这条命令如果调用的话，就会把 vData 中的5,6,7 拷贝到 6,7,8所在的位置

最终 vData的内容将会是 [0,1,2,3,4,5,5,6,7,9,100]

这里的例子中只有一条指令，如果要多条指令，请接着 _instructs_ 最后的 3,0 继续往后写指令

通常一个有意义的任务中，必定会要有读取调用参数，和转账相关的指令

具体所有指令，请参考[任务指令集](dsysbinstruction_zh.md)，此处主要描述部署原理
